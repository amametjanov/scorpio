<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PIO: pio_darray_int.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PIO
   &#160;<span id="projectnumber">2.0.28</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>PIO&#160;User's&#160;Guide</span></a></li>
      <li><a href="annotated.html"><span>Appendix</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_43d99ce78fde0129422a9159c5186d57.html">ParallelIO</a></li><li class="navelem"><a class="el" href="dir_141a8219d9000c6e4137175db07b6601.html">src</a></li><li class="navelem"><a class="el" href="dir_f00dc8b6574f3e86f0c5dc7c00a526e4.html">clib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pio_darray_int.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Private functions to help read and write distributed arrays in PIO.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;config.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="pio_8h_source.html">pio.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="pio__internal_8h_source.html">pio_internal.h</a>&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pio_darray_int.c:</div>
<div class="dyncontent">
<div class="center"><img src="pio__darray__int_8c__incl.png" border="0" usemap="#pio__darray__int_8c" alt=""/></div>
<map name="pio__darray__int_8c" id="pio__darray__int_8c">
<area shape="rect" id="node3" href="pio_8h.html" title="Public headers for the PIO C interface. " alt="" coords="191,155,241,181"/><area shape="rect" id="node9" href="pio__internal_8h.html" title="Private headers and defines for the PIO C interface. " alt="" coords="311,80,409,107"/><area shape="rect" id="node10" href="bget_8h_source.html" title="bget.h" alt="" coords="265,155,323,181"/></map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af178de4ddf5149bb1a27b483e91a0d32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af178de4ddf5149bb1a27b483e91a0d32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bpool_free</b> (void *p)</td></tr>
<tr class="separator:af178de4ddf5149bb1a27b483e91a0d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccea86822eba560ac731a7a9f895632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ccea86822eba560ac731a7a9f895632"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>bpool_alloc</b> (bufsize sz)</td></tr>
<tr class="separator:a6ccea86822eba560ac731a7a9f895632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb265a4b03b59844fa784511a022911f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#adb265a4b03b59844fa784511a022911f">compute_buffer_init</a> (<a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *ios)</td></tr>
<tr class="memdesc:adb265a4b03b59844fa784511a022911f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the compute buffer to size pio_cnbuffer_limit.  <a href="#adb265a4b03b59844fa784511a022911f">More...</a><br/></td></tr>
<tr class="separator:adb265a4b03b59844fa784511a022911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaaa335b133602b7e1e965d2637e9184"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#afaaa335b133602b7e1e965d2637e9184">find_start_count</a> (int ndims, const int *dimlen, int fndims, <a class="el" href="structvar__desc__t.html">var_desc_t</a> *vdesc, <a class="el" href="structio__region.html">io_region</a> *region, size_t *start, size_t *count)</td></tr>
<tr class="memdesc:afaaa335b133602b7e1e965d2637e9184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill start/count arrays for <a class="el" href="pio__darray__int_8c.html#a095e39ac8c9e4e8cdb23c0e401a8ec34" title="Write a set of one or more aggregated arrays to output file. ">write_darray_multi_par()</a>.  <a href="#afaaa335b133602b7e1e965d2637e9184">More...</a><br/></td></tr>
<tr class="separator:afaaa335b133602b7e1e965d2637e9184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095e39ac8c9e4e8cdb23c0e401a8ec34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#a095e39ac8c9e4e8cdb23c0e401a8ec34">write_darray_multi_par</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, int nvars, int fndims, const int *varids, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, int fill, const int *frame)</td></tr>
<tr class="memdesc:a095e39ac8c9e4e8cdb23c0e401a8ec34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a set of one or more aggregated arrays to output file.  <a href="#a095e39ac8c9e4e8cdb23c0e401a8ec34">More...</a><br/></td></tr>
<tr class="separator:a095e39ac8c9e4e8cdb23c0e401a8ec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3003a240f9741ddecfdbb202ce6b21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#aef3003a240f9741ddecfdbb202ce6b21">find_all_start_count</a> (<a class="el" href="structio__region.html">io_region</a> *region, int maxregions, int fndims, int iodesc_ndims, const int *dimlen, <a class="el" href="structvar__desc__t.html">var_desc_t</a> *vdesc, size_t *tmp_start, size_t *tmp_count)</td></tr>
<tr class="memdesc:aef3003a240f9741ddecfdbb202ce6b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the tmp_start and tmp_count arrays, which contain the start and count arrays for all regions.  <a href="#aef3003a240f9741ddecfdbb202ce6b21">More...</a><br/></td></tr>
<tr class="separator:aef3003a240f9741ddecfdbb202ce6b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16c81480e986ab1f684e1612c1035b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#ae16c81480e986ab1f684e1612c1035b6">send_all_start_count</a> (<a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *ios, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, PIO_Offset llen, int maxregions, int nvars, int fndims, size_t *tmp_start, size_t *tmp_count, void *iobuf)</td></tr>
<tr class="memdesc:ae16c81480e986ab1f684e1612c1035b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function called by IO tasks other than IO task 0 to send their tmp_start/tmp_count arrays to IO task 0.  <a href="#ae16c81480e986ab1f684e1612c1035b6">More...</a><br/></td></tr>
<tr class="separator:ae16c81480e986ab1f684e1612c1035b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8962adeb628369df663bb35eeb86bc4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#a8962adeb628369df663bb35eeb86bc4f">recv_and_write_data</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, const int *varids, const int *frame, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, PIO_Offset llen, int maxregions, int nvars, int fndims, size_t *tmp_start, size_t *tmp_count, void *iobuf)</td></tr>
<tr class="memdesc:a8962adeb628369df663bb35eeb86bc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal function that is run only on IO proc 0.  <a href="#a8962adeb628369df663bb35eeb86bc4f">More...</a><br/></td></tr>
<tr class="separator:a8962adeb628369df663bb35eeb86bc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c45f0b205bcef5184404ac50567feb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#a41c45f0b205bcef5184404ac50567feb">write_darray_multi_serial</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, int nvars, int fndims, const int *varids, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, int fill, const int *frame)</td></tr>
<tr class="memdesc:a41c45f0b205bcef5184404ac50567feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a set of one or more aggregated arrays to output file in serial mode.  <a href="#a41c45f0b205bcef5184404ac50567feb">More...</a><br/></td></tr>
<tr class="separator:a41c45f0b205bcef5184404ac50567feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7c2e7f27153720438fe96ae0278917"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#afa7c2e7f27153720438fe96ae0278917">pio_read_darray_nc</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, int fndims, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, int vid, void *iobuf)</td></tr>
<tr class="memdesc:afa7c2e7f27153720438fe96ae0278917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an array of data from a file to the (parallel) IO library.  <a href="#afa7c2e7f27153720438fe96ae0278917">More...</a><br/></td></tr>
<tr class="separator:afa7c2e7f27153720438fe96ae0278917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9eabb82e11f4cfc5f296ecd5ce8b5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#a5f9eabb82e11f4cfc5f296ecd5ce8b5b">pio_read_darray_nc_serial</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, int fndims, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, int vid, void *iobuf)</td></tr>
<tr class="memdesc:a5f9eabb82e11f4cfc5f296ecd5ce8b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an array of data from a file to the (serial) IO library.  <a href="#a5f9eabb82e11f4cfc5f296ecd5ce8b5b">More...</a><br/></td></tr>
<tr class="separator:a5f9eabb82e11f4cfc5f296ecd5ce8b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b614dbe44ee8bd3a113090ebc2c23fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#a1b614dbe44ee8bd3a113090ebc2c23fd">flush_output_buffer</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, bool force, PIO_Offset addsize)</td></tr>
<tr class="memdesc:a1b614dbe44ee8bd3a113090ebc2c23fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the output buffer.  <a href="#a1b614dbe44ee8bd3a113090ebc2c23fd">More...</a><br/></td></tr>
<tr class="separator:a1b614dbe44ee8bd3a113090ebc2c23fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35aea71e1d8cb61a1b6bffc6a15731af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#a35aea71e1d8cb61a1b6bffc6a15731af">cn_buffer_report</a> (<a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *ios, bool collective)</td></tr>
<tr class="memdesc:a35aea71e1d8cb61a1b6bffc6a15731af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out info about the buffer for debug purposes.  <a href="#a35aea71e1d8cb61a1b6bffc6a15731af">More...</a><br/></td></tr>
<tr class="separator:a35aea71e1d8cb61a1b6bffc6a15731af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bb852697cc62d54b7528bc4cee47b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#a54bb852697cc62d54b7528bc4cee47b6">flush_buffer</a> (int ncid, <a class="el" href="structwmulti__buffer.html">wmulti_buffer</a> *wmb, bool flushtodisk)</td></tr>
<tr class="memdesc:a54bb852697cc62d54b7528bc4cee47b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the buffer.  <a href="#a54bb852697cc62d54b7528bc4cee47b6">More...</a><br/></td></tr>
<tr class="separator:a54bb852697cc62d54b7528bc4cee47b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270978141a60afa6ab0aa99aff7cf715"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pio__darray__int_8c.html#a270978141a60afa6ab0aa99aff7cf715">compute_maxaggregate_bytes</a> (<a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *ios, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc)</td></tr>
<tr class="memdesc:a270978141a60afa6ab0aa99aff7cf715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum aggregate number of bytes.  <a href="#a270978141a60afa6ab0aa99aff7cf715">More...</a><br/></td></tr>
<tr class="separator:a270978141a60afa6ab0aa99aff7cf715"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aabf3f9fc5a764a9107ad492e1559cd77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabf3f9fc5a764a9107ad492e1559cd77"></a>
PIO_Offset&#160;</td><td class="memItemRight" valign="bottom"><b>pio_buffer_size_limit</b></td></tr>
<tr class="separator:aabf3f9fc5a764a9107ad492e1559cd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a746679975777183db1fb4e3cb0381c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a746679975777183db1fb4e3cb0381c"></a>
bufsize&#160;</td><td class="memItemRight" valign="bottom"><b>pio_cnbuffer_limit</b> = 0</td></tr>
<tr class="separator:a9a746679975777183db1fb4e3cb0381c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89343a92bde7994f33f1f466022fa0fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89343a92bde7994f33f1f466022fa0fc"></a>
PIO_Offset&#160;</td><td class="memItemRight" valign="bottom"><b>maxusage</b></td></tr>
<tr class="separator:a89343a92bde7994f33f1f466022fa0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Private functions to help read and write distributed arrays in PIO. </p>
<p>When arrays are distributed, each processor holds some of the array. Only by combining the distributed arrays from all processor can the full array be obtained.</p>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a35aea71e1d8cb61a1b6bffc6a15731af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cn_buffer_report </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *&#160;</td>
          <td class="paramname"><em>ios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>collective</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out info about the buffer for debug purposes. </p>
<p>This should only be called when logging is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ios</td><td>pointer to the IO system structure </td></tr>
    <tr><td class="paramname">collective</td><td>true if collective report is desired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards </dd></dl>

</div>
</div>
<a class="anchor" id="adb265a4b03b59844fa784511a022911f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compute_buffer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *&#160;</td>
          <td class="paramname"><em>ios</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the compute buffer to size pio_cnbuffer_limit. </p>
<p>This routine initializes the compute buffer pool if the bget memory management is used. If malloc is used (that is, PIO_USE_MALLOC is non zero), this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ios</td><td>pointer to the iosystem descriptor which will use the new buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards </dd></dl>

</div>
</div>
<a class="anchor" id="a270978141a60afa6ab0aa99aff7cf715"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compute_maxaggregate_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *&#160;</td>
          <td class="paramname"><em>ios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum aggregate number of bytes. </p>
<p>This is called by <a class="el" href="pio__internal_8h.html#acd469d1ff342c427116bea9e9d307c79" title="Create the subset rearranger. ">subset_rearrange_create()</a> and <a class="el" href="pio__internal_8h.html#a4426524dce386030db9ce54bb4c26758" title="The box rearranger computes a mapping between IO tasks and compute tasks such that the data on IO tas...">box_rearrange_create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ios</td><td>pointer to the IO system structure. </td></tr>
    <tr><td class="paramname">iodesc</td><td>a pointer to decomposition description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards </dd></dl>

</div>
</div>
<a class="anchor" id="aef3003a240f9741ddecfdbb202ce6b21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_all_start_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structio__region.html">io_region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxregions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iodesc_ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dimlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvar__desc__t.html">var_desc_t</a> *&#160;</td>
          <td class="paramname"><em>vdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the tmp_start and tmp_count arrays, which contain the start and count arrays for all regions. </p>
<p>This is an internal function which is only called on io tasks. It is called by <a class="el" href="pio__darray__int_8c.html#a41c45f0b205bcef5184404ac50567feb" title="Write a set of one or more aggregated arrays to output file in serial mode. ">write_darray_multi_serial()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>pointer to the first in a linked list of regions. </td></tr>
    <tr><td class="paramname">maxregions</td><td>the number of regions in the list. </td></tr>
    <tr><td class="paramname">fndims</td><td>the number of dimensions in the file. </td></tr>
    <tr><td class="paramname">iodesc_ndims</td><td>the number of dimensions in the decomposition. </td></tr>
    <tr><td class="paramname">dimlen</td><td>the lengths of dimensions in the decomposition. </td></tr>
    <tr><td class="paramname">vdesc</td><td>pointer to an array of <a class="el" href="structvar__desc__t.html" title="Variable description structure. ">var_desc_t</a> for the vars being written. </td></tr>
    <tr><td class="paramname">tmp_start</td><td>pointer to an already allocaed array of length fndims * maxregions. This array will get the start values for all regions. </td></tr>
    <tr><td class="paramname">tmp_count</td><td>pointer to an already allocaed array of length fndims * maxregions. This array will get the count values for all regions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a class="anchor" id="afaaa335b133602b7e1e965d2637e9184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_start_count </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dimlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvar__desc__t.html">var_desc_t</a> *&#160;</td>
          <td class="paramname"><em>vdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__region.html">io_region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill start/count arrays for <a class="el" href="pio__darray__int_8c.html#a095e39ac8c9e4e8cdb23c0e401a8ec34" title="Write a set of one or more aggregated arrays to output file. ">write_darray_multi_par()</a>. </p>
<p>This is an internal function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndims</td><td>the number of dims in the decomposition. </td></tr>
    <tr><td class="paramname">dimlen</td><td>the lengths of dims in the decomposition. </td></tr>
    <tr><td class="paramname">fndims</td><td>the number of dims in the file. </td></tr>
    <tr><td class="paramname">vdesc</td><td>pointer to the <a class="el" href="structvar__desc__t.html" title="Variable description structure. ">var_desc_t</a> info. </td></tr>
    <tr><td class="paramname">region</td><td>pointer to a region. </td></tr>
    <tr><td class="paramname">start</td><td>an already-allocated array which gets the start values. </td></tr>
    <tr><td class="paramname">count</td><td>an already-allocated array which gets the count values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ed Hartnett </dd></dl>

</div>
</div>
<a class="anchor" id="a54bb852697cc62d54b7528bc4cee47b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flush_buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwmulti__buffer.html">wmulti_buffer</a> *&#160;</td>
          <td class="paramname"><em>wmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushtodisk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>identifies the netCDF file. </td></tr>
    <tr><td class="paramname">wmb</td><td>pointer to the <a class="el" href="structwmulti__buffer.html" title="The multi buffer holds data from one or more variables. ">wmulti_buffer</a> structure. </td></tr>
    <tr><td class="paramname">flushtodisk</td><td>if true, then flush data to disk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a class="anchor" id="a1b614dbe44ee8bd3a113090ebc2c23fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flush_output_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PIO_Offset&#160;</td>
          <td class="paramname"><em>addsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the output buffer. </p>
<p>This is only relevant for files opened with pnetcdf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to </td></tr>
    <tr><td class="paramname">force</td><td>true to force the flushing of the buffer </td></tr>
    <tr><td class="paramname">addsize</td><td>additional size to add to buffer (in bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a class="anchor" id="afa7c2e7f27153720438fe96ae0278917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pio_read_darray_nc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>iobuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an array of data from a file to the (parallel) IO library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to </td></tr>
    <tr><td class="paramname">fndims</td><td>The number of dims in the file </td></tr>
    <tr><td class="paramname">iodesc</td><td>a pointer to the defined iodescriptor for the buffer </td></tr>
    <tr><td class="paramname">vid</td><td>the variable id to be read </td></tr>
    <tr><td class="paramname">iobuf</td><td>the buffer to be read into from this mpi task. May be null. for example we have 8 ionodes and a distributed array with global size 4, then at least 4 nodes will have a null iobuf. In practice the box rearranger trys to have at least blocksize bytes on each io task and so if the total number of bytes to write is less than blocksize*numiotasks then some iotasks will have a NULL iobuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a class="anchor" id="a5f9eabb82e11f4cfc5f296ecd5ce8b5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pio_read_darray_nc_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>iobuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an array of data from a file to the (serial) IO library. </p>
<p>This function is only used with netCDF classic and netCDF-4 serial iotypes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to </td></tr>
    <tr><td class="paramname">fndims</td><td>The number of dims in the file </td></tr>
    <tr><td class="paramname">iodesc</td><td>a pointer to the defined iodescriptor for the buffer </td></tr>
    <tr><td class="paramname">vid</td><td>the variable id to be read. </td></tr>
    <tr><td class="paramname">iobuf</td><td>the buffer to be written from this mpi task. May be null. for example we have 8 ionodes and a distributed array with global size 4, then at least 4 nodes will have a null iobuf. In practice the box rearranger trys to have at least blocksize bytes on each io task and so if the total number of bytes to write is less than blocksize * numiotasks then some iotasks will have a NULL iobuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a class="anchor" id="a8962adeb628369df663bb35eeb86bc4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int recv_and_write_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>varids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PIO_Offset&#160;</td>
          <td class="paramname"><em>llen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxregions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>iobuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal function that is run only on IO proc 0. </p>
<p>It receives data from all the other IO tasks, and write that data to disk. This is called from <a class="el" href="pio__darray__int_8c.html#a41c45f0b205bcef5184404ac50567feb" title="Write a set of one or more aggregated arrays to output file in serial mode. ">write_darray_multi_serial()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to. </td></tr>
    <tr><td class="paramname">varids</td><td>an array of the variable ids to be written </td></tr>
    <tr><td class="paramname">frame</td><td>the record dimension for each of the nvars variables in iobuf. NULL if this iodesc contains non-record vars. </td></tr>
    <tr><td class="paramname">iodesc</td><td>pointer to the decomposition info. </td></tr>
    <tr><td class="paramname">llen</td><td>length of the iobuffer on this task for a single field. </td></tr>
    <tr><td class="paramname">maxregions</td><td>max number of blocks to be written from this iotask. </td></tr>
    <tr><td class="paramname">nvars</td><td>the number of variables to be written with this decomposition. </td></tr>
    <tr><td class="paramname">fndims</td><td>the number of dimensions in the file. </td></tr>
    <tr><td class="paramname">tmp_start</td><td>pointer to an already allocaed array of length fndims * maxregions. This array will get the start values for all regions. </td></tr>
    <tr><td class="paramname">tmp_count</td><td>pointer to an already allocaed array of length fndims * maxregions. This array will get the count values for all regions. </td></tr>
    <tr><td class="paramname">iobuf</td><td>the buffer to be written from this mpi task. May be null. for example we have 8 ionodes and a distributed array with global size 4, then at least 4 nodes will have a null iobuf. In practice the box rearranger trys to have at least blocksize bytes on each io task and so if the total number of bytes to write is less than blocksize*numiotasks then some iotasks will have a NULL iobuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a class="anchor" id="ae16c81480e986ab1f684e1612c1035b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int send_all_start_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *&#160;</td>
          <td class="paramname"><em>ios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PIO_Offset&#160;</td>
          <td class="paramname"><em>llen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxregions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>iobuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function called by IO tasks other than IO task 0 to send their tmp_start/tmp_count arrays to IO task 0. </p>
<p>This is an internal function which is only called on io tasks other than IO task 0. It is called by <a class="el" href="pio__darray__int_8c.html#a41c45f0b205bcef5184404ac50567feb" title="Write a set of one or more aggregated arrays to output file in serial mode. ">write_darray_multi_serial()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a class="anchor" id="a095e39ac8c9e4e8cdb23c0e401a8ec34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_darray_multi_par </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>varids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a set of one or more aggregated arrays to output file. </p>
<p>This function is only used with parallel-netcdf and netcdf-4 parallel iotypes. Serial io types use <a class="el" href="pio__darray__int_8c.html#a41c45f0b205bcef5184404ac50567feb" title="Write a set of one or more aggregated arrays to output file in serial mode. ">write_darray_multi_serial()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to </td></tr>
    <tr><td class="paramname">nvars</td><td>the number of variables to be written with this decomposition. </td></tr>
    <tr><td class="paramname">vid</td><td>an array of the variable ids to be written. </td></tr>
    <tr><td class="paramname">iodesc</td><td>pointer to the <a class="el" href="structio__desc__t.html" title="IO descriptor structure. ">io_desc_t</a> info. </td></tr>
    <tr><td class="paramname">fill</td><td>Non-zero if this write is fill data. </td></tr>
    <tr><td class="paramname">frame</td><td>the record dimension for each of the nvars variables in iobuf. NULL if this iodesc contains non-record vars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a class="anchor" id="a41c45f0b205bcef5184404ac50567feb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_darray_multi_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>varids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a set of one or more aggregated arrays to output file in serial mode. </p>
<p>This function is called for netCDF classic and netCDF-4 serial iotypes. Parallel iotypes use <a class="el" href="pio__darray__int_8c.html#a095e39ac8c9e4e8cdb23c0e401a8ec34" title="Write a set of one or more aggregated arrays to output file. ">write_darray_multi_par()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to. </td></tr>
    <tr><td class="paramname">nvars</td><td>the number of variables to be written with this decomposition. </td></tr>
    <tr><td class="paramname">varids</td><td>an array of the variable ids to be written </td></tr>
    <tr><td class="paramname">iodesc</td><td>pointer to the decomposition info. </td></tr>
    <tr><td class="paramname">fill</td><td>Non-zero if this write is fill data. </td></tr>
    <tr><td class="paramname">frame</td><td>the record dimension for each of the nvars variables in iobuf. NULL if this iodesc contains non-record vars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 22 2019 11:11:12 for PIO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
